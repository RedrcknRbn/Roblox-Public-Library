(If you install the Todo+ extension you can toggle a task being done with Alt+d and create a new task with Ctrl+Enter)
--------------------------
TopBar:
	✔ Credit https://github.com/1ForeverHD/HDAdmin/tree/master/Projects/Topbar%2B for coords/sizes
	✔ Transparency of bg image
	✔ Settings gear (from TopBar+): http://www.roblox.com/asset/?id=2484556379
	Music:
		✔ Get musical note icon
		✔ Create dropdown list
		☐ Make the gui functional
	About or FAQ:
		✔ Get icon (maybe a "?")
		✔ Should have commands/controls and credits
	Book Finder:
		✔ Get magnifying icon

Profile / Music:
	☐ Profile *has* music and can ask Music to serialize/etc
	☐ Music has functions for active playlist/etc instead of Profile
	Server-side Note:
		No need to check whether the profile has changed; it's easier to just assume that it has and autosave regardless

Custom Playlist:
	Data structure to save:
		☐ Each playlist must have a unique id (per user)
		☐ Must store the "next" playlist id for each user
		☐ All requests/functions should use this id (they currently use the name)
	Checks to perform on server:
		☐ Name must be unique
		✔ Name must get through filtering or be "Custom #%d+"
	For new playlists, server must support either:
		☐ 1. Can change the name of a playlist that doesn't exist
		☐ 2. Can create an empty playlist (and maybe even save it?)
	On init:
		✔ Dropdown contains all editable playlists
		☐ Open editor to active custom playlist else any custom playlist else "Custom #1"
	When user changes the name of the playlist:

	✔ Gui will have "x" to delete entry and then 1+ rows for sound IDs
	✔ after pressing enter a label with Title (Length) is supposed to show up (maybe "by Creator" as well?)
	On Enter of one of the IDs:
		✔ Validate the input. If it's no good, revert to previous value.
			✔ Tell user what's wrong by sending a notification
		☐ Music:TrySetCustomPlaylistTrack(index, id)
			will return true OR false, reason
			if it fails, tell user why via notification like before
			& revert text box
		☐ If successful, if there is no empty text box, create another row
	On startup:
		☐ Populate the Music list with all the default music (with Name, Length, creator)
		☐ On "+" Activated, copy into new slot in the playlist
	> For now, do not support multiple playlists - most players will only use 1 at most (and not popular feature anyway)
	Currently playing display:
		> In the main menu, or the custom playlist editor
		☐ Create this display
		☐ When the current music changes, activate an event
		☐ When the event fires, update the Currently Playing display

Book Pouch/Inventory:
	☐ Perhaps "Books" or "Inventory" text should be on far left side (rotated 90 degrees), at least when the pouch is closed
	☐ Starts out open (but invisible if you're not carrying any books)
	☐ A ScrollingFrame (only scrolls if needed) to hold each book
	☐ It should save books you previously had in your inventory
	☐ An "x" beside each book to get rid of it
	☐ When you click on a book, it opens it up

Teleport:
	WhirlPlay is working on this
	☐ Shared teleport code
	☐ ConfirmationBox module (that doesn't know anything about teleport)
	☐ Have teleport scripts use shared teleport code
	☐ Automatically fetch place name from id and display it in the model and the confirmation message
	☐ Ensure message isn't triggered multiple times while the player is idling/moving around
	☐ Auto-cancel if the player moves away a certain distance
	☐ If a player declines, don't let the message trigger again until they've moved away at least a bit

	☐ Can we write any tests for this?
		> Can't easily test player



Bugs:
	✔ Can't toggle Music on/off
	✔ Toggling music on/off doesn't actually work
	✔ Playlist says "Center" instead of "Default"
	✔ Playlist label should be init to whatever the user's preference is and updated appropriately
	✔ Opening Book Finder doesn't close menu

Profile:
	✔ Algorithm that can handle merging
	> see SaveableSet
	☐ Add Recently Read books to profile (OR just use book inventory?)
	☐ serialize profile and its contents (ex via SaveableSet) both for over the network and to/from the data store
		☐ for data store only, need to be able to encode with a version so that they can be upgraded over time (or use tables with string keys that we can change over time)
			x if we use string keys to upgrade, then you have to check every possible string key, "just in case"

New Book Gui:
	For now we can add on to the existing book gui
	☐ favoriting a book
		☐ ImageButton star, like on Roblox's site. Change its icon when the change is confirmed (put it in a grayed out state while saving)
		☐ store it in the user's profile
		☐ store it in the book's list of people who have favourited it using UpdateAsync
	☐ mark book as read/unread
		☐ TextButton that grays out while confirming change; text must change to "Mark as Read"/"Mark as Unread"
		☐ store in user's profile
		☐ store/remove it in book's list of who's read it (UpdateAsync)
	☐ some way to add to "pouch"
	☐ need to rewrite the BookGui script

Consider these assets:
	Star = "rbxassetid://706790939"
	StarOutline = "rbxassetid://706767490"
	StarWithBorder = "rbxassetid://706767649"

--------------------------
Data Flow Plan (Profiles):
--------------------------
OnEnter:
	☐ DataStoreLoad -> profileData
	☐ Profile.Deserialize/Decode -> profile
	☐ profiles[player] = profile
	☐ fire profileLoaded for the player (can be created on demand; only fire if it exists)
	☐ mark when next autosave can occur

User clicks Music Off:
	☐ gui asks Music
	☐ Music gets a ref to the current profile and can check :IsMusicEnabled()
	☐ Music should then react to new value of MusicEnabled
	☐ ClientProfile uses remote to notify server of change
	☐ Server records it and marks profile as changed
	☐ activate autosave routine/queue as needed

User clicks a book:
	☐ book gui asks ClientProfile for fav/read/etc details
	☐ book gui asks BookContent module for content (which keeps it only while the book is in your inventory; maybe also the last book you had opened)
		☐ asks for content from server

Say we use the most basic table syntax (so it's simple to view/edit). What data could be stored in one key?
ex, Favorites=[1,532,531]
so if we assume there are 10k books and that each ID is 4 digits long, then we need 5 digits per favourite is ~50,000 characters and the limit is 260,000 characters!
So we could do that for now